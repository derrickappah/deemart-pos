-- =====================================================
-- COMPREHENSIVE SUPABASE SCHEMA FOR POS SYSTEM
-- DeeMart POS - Complete Backend Database Schema
-- =====================================================

-- Enable required extensions
create extension if not exists "uuid-ossp";
create extension if not exists "pg_trgm"; -- For text search

-- =====================================================
-- CLEANUP: DROP EXISTING OBJECTS (if they exist)
-- =====================================================
-- Drop in reverse dependency order to avoid foreign key errors
-- Using DO block to safely handle any errors

do $$
begin
  -- Drop views first
  drop view if exists public.category_sales cascade;
  drop view if exists public.top_products cascade;
  drop view if exists public.sales_summary cascade;
  drop view if exists public.low_stock_products cascade;

  -- Drop functions (CASCADE handles dependencies)
  drop function if exists public.update_updated_at_column() cascade;
  drop function if exists public.handle_customer_payment() cascade;
  drop function if exists public.update_customer_balance() cascade;
  drop function if exists public.handle_sale_stock_update() cascade;
  drop function if exists public.update_product_stock() cascade;
  drop function if exists public.generate_po_number() cascade;
  drop function if exists public.generate_sale_number() cascade;
  drop function if exists public.handle_new_user() cascade;

  -- Drop tables in reverse dependency order (child tables first)
  -- Using CASCADE will also drop dependent objects (policies, indexes, triggers, etc.)
  drop table if exists public.customer_payments cascade;
  drop table if exists public.purchase_order_items cascade;
  drop table if exists public.purchase_orders cascade;
  drop table if exists public.stock_movements cascade;
  drop table if exists public.payment_records cascade;
  drop table if exists public.sale_items cascade;
  drop table if exists public.sales cascade;
  drop table if exists public.products cascade;
  drop table if exists public.user_profiles cascade;
  drop table if exists public.customers cascade;
  drop table if exists public.suppliers cascade;
  drop table if exists public.categories cascade;
  drop table if exists public.branches cascade;

exception when others then
  -- Ignore any errors during cleanup - tables/functions may not exist
  raise notice 'Cleanup completed with some warnings (this is normal if running for the first time)';
end $$;

-- Drop trigger on auth.users (system table, must be done separately)
drop trigger if exists on_auth_user_created on auth.users;

-- =====================================================
-- CORE TABLES
-- =====================================================

-- Branches Table
create table public.branches (
  id bigint generated by default as identity primary key,
  name text not null,
  address text,
  phone text,
  email text,
  is_active boolean default true,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Categories Table
create table public.categories (
  id bigint generated by default as identity primary key,
  name text not null unique,
  description text,
  is_active boolean default true,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Suppliers Table (must be created before products since products reference suppliers)
create table public.suppliers (
  id bigint generated by default as identity primary key,
  name text not null,
  contact_person text,
  phone text not null,
  email text,
  address text,
  tax_id text,
  payment_terms text,
  is_active boolean default true,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Products Table
create table public.products (
  id bigint generated by default as identity primary key,
  name text not null,
  barcode text unique,
  sku text unique,
  category_id bigint references public.categories(id) on delete set null,
  cost_price numeric(10,2) default 0,
  retail_price numeric(10,2) not null,
  wholesale_price numeric(10,2),
  stock_quantity integer default 0 not null,
  min_stock_level integer default 10,
  max_stock_level integer,
  image_url text,
  expiry_date date,
  supplier_id bigint references public.suppliers(id) on delete set null,
  is_active boolean default true,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Customers Table
create table public.customers (
  id bigint generated by default as identity primary key,
  name text not null,
  phone text not null,
  email text,
  address text,
  credit_limit numeric(10,2) default 0,
  outstanding_balance numeric(10,2) default 0,
  loyalty_points integer default 0,
  is_active boolean default true,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- User Profiles Table (for role-based access control)
create table public.user_profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  role text check (role in ('admin', 'cashier', 'manager')) default 'cashier',
  branch_id bigint references public.branches(id) on delete set null,
  phone text,
  is_active boolean default true,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Sales Table
create table public.sales (
  id uuid default uuid_generate_v4() primary key,
  sale_number text unique not null,
  cashier_id uuid references auth.users(id),
  customer_id bigint references public.customers(id) on delete set null,
  branch_id bigint references public.branches(id) on delete set null,
  total_amount numeric(10,2) not null,
  discount_amount numeric(10,2) default 0,
  tax_amount numeric(10,2) default 0,
  final_amount numeric(10,2) not null,
  payment_method text not null, -- 'cash', 'momo', 'card', 'bank_transfer'
  is_credit boolean default false,
  amount_paid numeric(10,2) default 0,
  balance_due numeric(10,2) default 0,
  change_amount numeric(10,2) default 0,
  status text default 'completed', -- 'completed', 'pending', 'cancelled', 'refunded'
  notes text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Sale Items Table
create table public.sale_items (
  id bigint generated by default as identity primary key,
  sale_id uuid references public.sales(id) on delete cascade,
  product_id bigint references public.products(id),
  quantity integer not null,
  unit_price numeric(10,2) not null,
  discount_percent numeric(5,2) default 0,
  discount_amount numeric(10,2) default 0,
  total_price numeric(10,2) not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Payment Records Table (for split payments)
create table public.payment_records (
  id bigint generated by default as identity primary key,
  sale_id uuid references public.sales(id) on delete cascade,
  payment_method text not null,
  amount numeric(10,2) not null,
  reference_number text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Stock Movements Table (for inventory tracking)
create table public.stock_movements (
  id bigint generated by default as identity primary key,
  product_id bigint references public.products(id) on delete cascade,
  movement_type text not null, -- 'sale', 'purchase', 'adjustment', 'return', 'transfer'
  quantity integer not null, -- positive for additions, negative for deductions
  previous_stock integer not null,
  new_stock integer not null,
  reference_id uuid, -- can reference sale_id, purchase_order_id, etc.
  reference_type text, -- 'sale', 'purchase_order', 'adjustment', etc.
  notes text,
  created_by uuid references auth.users(id),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Purchase Orders Table
create table public.purchase_orders (
  id uuid default uuid_generate_v4() primary key,
  po_number text unique not null,
  supplier_id bigint references public.suppliers(id) on delete restrict,
  branch_id bigint references public.branches(id) on delete set null,
  order_date date not null default current_date,
  expected_delivery_date date,
  total_amount numeric(10,2) not null,
  status text default 'pending', -- 'pending', 'ordered', 'received', 'cancelled'
  notes text,
  created_by uuid references auth.users(id),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Purchase Order Items Table
create table public.purchase_order_items (
  id bigint generated by default as identity primary key,
  purchase_order_id uuid references public.purchase_orders(id) on delete cascade,
  product_id bigint references public.products(id) on delete restrict,
  quantity_ordered integer not null,
  quantity_received integer default 0,
  unit_cost numeric(10,2) not null,
  total_cost numeric(10,2) not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Customer Payments Table (for credit sales payments)
create table public.customer_payments (
  id bigint generated by default as identity primary key,
  customer_id bigint references public.customers(id) on delete restrict,
  sale_id uuid references public.sales(id) on delete set null,
  amount numeric(10,2) not null,
  payment_method text not null,
  reference_number text,
  notes text,
  created_by uuid references auth.users(id),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- =====================================================
-- INDEXES FOR PERFORMANCE
-- =====================================================

-- Products indexes
create index idx_products_barcode on public.products(barcode);
create index idx_products_category on public.products(category_id);
create index idx_products_supplier on public.products(supplier_id);
create index idx_products_name_search on public.products using gin(name gin_trgm_ops);

-- Sales indexes
create index idx_sales_cashier on public.sales(cashier_id);
create index idx_sales_customer on public.sales(customer_id);
create index idx_sales_branch on public.sales(branch_id);
create index idx_sales_date on public.sales(created_at);
create index idx_sales_status on public.sales(status);
create index idx_sales_number on public.sales(sale_number);

-- Sale items indexes
create index idx_sale_items_sale on public.sale_items(sale_id);
create index idx_sale_items_product on public.sale_items(product_id);

-- Stock movements indexes
create index idx_stock_movements_product on public.stock_movements(product_id);
create index idx_stock_movements_date on public.stock_movements(created_at);
create index idx_stock_movements_type on public.stock_movements(movement_type);

-- Purchase orders indexes
create index idx_po_supplier on public.purchase_orders(supplier_id);
create index idx_po_date on public.purchase_orders(order_date);
create index idx_po_status on public.purchase_orders(status);

-- Customers indexes
create index idx_customers_phone on public.customers(phone);
create index idx_customers_name_search on public.customers using gin(name gin_trgm_ops);

-- Suppliers indexes
create index idx_suppliers_name_search on public.suppliers using gin(name gin_trgm_ops);

-- =====================================================
-- FUNCTIONS
-- =====================================================

-- Function to generate sale number (trigger function)
create or replace function public.generate_sale_number()
returns trigger as $$
declare
  new_number text;
  today_date text;
  last_number integer;
  extracted_text text;
begin
  -- Only generate if sale_number is not already set
  if new.sale_number is null or new.sale_number = '' then
    today_date := to_char(current_date, 'YYYYMMDD');
    
    -- Safely extract and parse the number part from sale_number
    -- Format: SALE-YYYYMMDD-####, so we extract from position 14 (after "SALE-YYYYMMDD-")
    select coalesce(
      max(
        case 
          when sale_number ~ '^SALE-\d{8}-\d+$' then
            -- Extract the number part after the second dash
            cast(substring(sale_number from 'SALE-\d{8}-(\d+)$') as integer)
          else
            null
        end
      ), 
      0
    ) + 1
    into last_number
    from public.sales
    where sale_number like 'SALE-' || today_date || '%'
      and sale_number ~ '^SALE-\d{8}-\d+$'; -- Only consider properly formatted sale numbers
    
    new_number := 'SALE-' || today_date || '-' || lpad(last_number::text, 4, '0');
    new.sale_number := new_number;
  end if;
  
  return new;
end;
$$ language plpgsql;

-- Function to generate purchase order number (trigger function)
create or replace function public.generate_po_number()
returns trigger as $$
declare
  new_number text;
  today_date text;
  last_number integer;
begin
  -- Only generate if po_number is not already set
  if new.po_number is null or new.po_number = '' then
    today_date := to_char(current_date, 'YYYYMMDD');
    
    select coalesce(max(cast(substring(po_number from 4) as integer)), 0) + 1
    into last_number
    from public.purchase_orders
    where po_number like 'PO-' || today_date || '%';
    
    new_number := 'PO-' || today_date || '-' || lpad(last_number::text, 4, '0');
    new.po_number := new_number;
  end if;
  
  return new;
end;
$$ language plpgsql;

-- Function to update product stock
create or replace function public.update_product_stock()
returns trigger as $$
declare
  old_stock integer;
  new_stock integer;
begin
  -- Get current stock
  select stock_quantity into old_stock
  from public.products
  where id = new.product_id;
  
  -- Calculate new stock based on movement type
  if new.movement_type = 'sale' then
    new_stock := old_stock - abs(new.quantity);
  elsif new.movement_type in ('purchase', 'return', 'adjustment') then
    new_stock := old_stock + abs(new.quantity);
  else
    new_stock := old_stock;
  end if;
  
  -- Update stock quantity
  update public.products
  set stock_quantity = new_stock,
      updated_at = now()
  where id = new.product_id;
  
  -- Update the new_stock field in the movement record
  new.new_stock := new_stock;
  
  return new;
end;
$$ language plpgsql security definer;

-- Trigger to automatically update stock when sale items are created
-- Uses SECURITY DEFINER to bypass RLS when inserting stock movements
create or replace function public.handle_sale_stock_update()
returns trigger as $$
begin
  -- Deduct stock when sale item is created
  insert into public.stock_movements (
    product_id,
    movement_type,
    quantity,
    previous_stock,
    new_stock,
    reference_id,
    reference_type,
    created_by
  )
  select
    new.product_id,
    'sale',
    -new.quantity,
    p.stock_quantity,
    p.stock_quantity - new.quantity,
    new.sale_id,
    'sale',
    (select cashier_id from public.sales where id = new.sale_id)
  from public.products p
  where p.id = new.product_id;
  
  -- Update product stock
  update public.products
  set stock_quantity = stock_quantity - new.quantity,
      updated_at = now()
  where id = new.product_id;
  
  return new;
end;
$$ language plpgsql security definer;

-- Function to automatically create user profile on signup
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.user_profiles (id, email, full_name)
  values (
    new.id,
    new.email,
    coalesce(new.raw_user_meta_data->>'full_name', split_part(new.email, '@', 1))
  );
  return new;
end;
$$ language plpgsql security definer;

-- Function to update customer balance on credit sale
-- Uses SECURITY DEFINER to bypass RLS when updating customer balance
create or replace function public.update_customer_balance()
returns trigger as $$
begin
  if new.is_credit = true and new.customer_id is not null then
    update public.customers
    set outstanding_balance = outstanding_balance + new.balance_due,
        updated_at = now()
    where id = new.customer_id;
  end if;
  return new;
end;
$$ language plpgsql security definer;

-- Function to update customer balance on payment
-- Uses SECURITY DEFINER to bypass RLS when updating customer balance
create or replace function public.handle_customer_payment()
returns trigger as $$
begin
  update public.customers
  set outstanding_balance = outstanding_balance - new.amount,
      updated_at = now()
  where id = new.customer_id;
  
  -- Update sale balance if payment is for a specific sale
  if new.sale_id is not null then
    update public.sales
    set balance_due = balance_due - new.amount,
        amount_paid = amount_paid + new.amount,
        updated_at = now()
    where id = new.sale_id;
  end if;
  
  return new;
end;
$$ language plpgsql security definer;

-- Function to update updated_at timestamp
create or replace function public.update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Security definer function to check user role (bypasses RLS to prevent infinite recursion)
-- This function runs with the privileges of the function owner, not the caller
create or replace function public.is_user_admin()
returns boolean as $$
begin
  return exists (
    select 1 from public.user_profiles
    where id = auth.uid() and role = 'admin'
  );
end;
$$ language plpgsql security definer;

-- Security definer function to check if user is admin or manager
create or replace function public.is_user_admin_or_manager()
returns boolean as $$
begin
  return exists (
    select 1 from public.user_profiles
    where id = auth.uid() and role in ('admin', 'manager')
  );
end;
$$ language plpgsql security definer;

-- =====================================================
-- TRIGGERS
-- =====================================================

-- Trigger to create profile on user signup
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Trigger to generate sale number
create trigger generate_sale_number_trigger
  before insert on public.sales
  for each row
  execute function public.generate_sale_number();

-- Trigger to generate purchase order number
create trigger generate_po_number_trigger
  before insert on public.purchase_orders
  for each row
  execute function public.generate_po_number();

-- Trigger to update stock when sale items are created
create trigger sale_item_stock_update
  after insert on public.sale_items
  for each row
  execute function public.handle_sale_stock_update();

-- Trigger to update customer balance on credit sale
create trigger update_customer_balance_trigger
  after insert on public.sales
  for each row
  execute function public.update_customer_balance();

-- Trigger to handle customer payments
create trigger handle_customer_payment_trigger
  after insert on public.customer_payments
  for each row
  execute function public.handle_customer_payment();

-- Triggers to update updated_at timestamp
create trigger update_products_updated_at
  before update on public.products
  for each row
  execute function public.update_updated_at_column();

create trigger update_categories_updated_at
  before update on public.categories
  for each row
  execute function public.update_updated_at_column();

create trigger update_customers_updated_at
  before update on public.customers
  for each row
  execute function public.update_updated_at_column();

create trigger update_suppliers_updated_at
  before update on public.suppliers
  for each row
  execute function public.update_updated_at_column();

create trigger update_sales_updated_at
  before update on public.sales
  for each row
  execute function public.update_updated_at_column();

create trigger update_user_profiles_updated_at
  before update on public.user_profiles
  for each row
  execute function public.update_updated_at_column();

create trigger update_branches_updated_at
  before update on public.branches
  for each row
  execute function public.update_updated_at_column();

create trigger update_purchase_orders_updated_at
  before update on public.purchase_orders
  for each row
  execute function public.update_updated_at_column();

-- =====================================================
-- VIEWS FOR ANALYTICS
-- =====================================================

-- Sales summary view
create or replace view public.sales_summary as
select
  date(created_at) as sale_date,
  count(*) as total_sales,
  sum(final_amount) as total_revenue,
  sum(case when payment_method = 'cash' then final_amount else 0 end) as cash_sales,
  sum(case when payment_method = 'momo' then final_amount else 0 end) as momo_sales,
  sum(case when payment_method = 'card' then final_amount else 0 end) as card_sales,
  sum(case when is_credit = true then final_amount else 0 end) as credit_sales
from public.sales
where status = 'completed'
group by date(created_at);

-- Top products view
create or replace view public.top_products as
select
  p.id,
  p.name,
  p.category_id,
  c.name as category_name,
  sum(si.quantity) as total_sold,
  sum(si.total_price) as total_revenue
from public.sale_items si
join public.products p on si.product_id = p.id
left join public.categories c on p.category_id = c.id
join public.sales s on si.sale_id = s.id
where s.status = 'completed'
group by p.id, p.name, p.category_id, c.name
order by total_sold desc;

-- Category distribution view
create or replace view public.category_sales as
select
  c.id,
  c.name as category_name,
  count(distinct s.id) as total_sales,
  sum(si.quantity) as total_items_sold,
  sum(si.total_price) as total_revenue
from public.categories c
left join public.products p on c.id = p.category_id
left join public.sale_items si on p.id = si.product_id
left join public.sales s on si.sale_id = s.id and s.status = 'completed'
group by c.id, c.name
order by total_revenue desc nulls last;

-- Low stock products view
create or replace view public.low_stock_products as
select
  p.id,
  p.name,
  p.stock_quantity,
  p.min_stock_level,
  c.name as category_name,
  (p.min_stock_level - p.stock_quantity) as units_below_min
from public.products p
left join public.categories c on p.category_id = c.id
where p.is_active = true
  and p.stock_quantity <= p.min_stock_level
order by (p.min_stock_level - p.stock_quantity) desc;

-- =====================================================
-- ROW LEVEL SECURITY (RLS)
-- =====================================================

-- Enable RLS on all tables
alter table public.branches enable row level security;
alter table public.categories enable row level security;
alter table public.products enable row level security;
alter table public.sales enable row level security;
alter table public.sale_items enable row level security;
alter table public.customers enable row level security;
alter table public.suppliers enable row level security;
alter table public.user_profiles enable row level security;
alter table public.payment_records enable row level security;
alter table public.stock_movements enable row level security;
alter table public.purchase_orders enable row level security;
alter table public.purchase_order_items enable row level security;
alter table public.customer_payments enable row level security;

-- RLS Policies for branches
create policy "Anyone can view active branches"
  on public.branches for select
  using (is_active = true);

create policy "Admins and managers can manage branches"
  on public.branches for all
  using (public.is_user_admin_or_manager());

-- RLS Policies for categories
create policy "Authenticated users can view categories"
  on public.categories for select
  using (auth.role() = 'authenticated' and is_active = true);

create policy "Admins and managers can manage categories"
  on public.categories for all
  using (public.is_user_admin_or_manager());

-- RLS Policies for products
create policy "Authenticated users can view products"
  on public.products for select
  using (auth.role() = 'authenticated' and is_active = true);

create policy "Admins and managers can manage products"
  on public.products for all
  using (public.is_user_admin_or_manager());

-- RLS Policies for sales
create policy "Authenticated users can view sales"
  on public.sales for select
  using (auth.role() = 'authenticated');

create policy "Authenticated users can create sales"
  on public.sales for insert
  with check (auth.role() = 'authenticated');

create policy "Admins and managers can update sales"
  on public.sales for update
  using (public.is_user_admin_or_manager());

-- RLS Policies for sale_items
create policy "Authenticated users can view sale items"
  on public.sale_items for select
  using (auth.role() = 'authenticated');

create policy "Authenticated users can create sale items"
  on public.sale_items for insert
  with check (auth.role() = 'authenticated');

-- RLS Policies for customers
create policy "Authenticated users can view customers"
  on public.customers for select
  using (auth.role() = 'authenticated' and is_active = true);

create policy "Admins and managers can manage customers"
  on public.customers for all
  using (public.is_user_admin_or_manager());

-- RLS Policies for suppliers
create policy "Authenticated users can view suppliers"
  on public.suppliers for select
  using (auth.role() = 'authenticated' and is_active = true);

create policy "Admins and managers can manage suppliers"
  on public.suppliers for all
  using (public.is_user_admin_or_manager());

-- RLS Policies for user_profiles
create policy "Users can view their own profile"
  on public.user_profiles for select
  using (auth.uid() = id);

create policy "Admins can view all profiles"
  on public.user_profiles for select
  using (public.is_user_admin());

create policy "Users can update their own profile"
  on public.user_profiles for update
  using (auth.uid() = id);

create policy "Admins can update all profiles"
  on public.user_profiles for update
  using (public.is_user_admin());

-- RLS Policies for payment_records
create policy "Authenticated users can view payment records"
  on public.payment_records for select
  using (auth.role() = 'authenticated');

create policy "Authenticated users can create payment records"
  on public.payment_records for insert
  with check (auth.role() = 'authenticated');

-- RLS Policies for stock_movements
create policy "Authenticated users can view stock movements"
  on public.stock_movements for select
  using (auth.role() = 'authenticated');

create policy "Admins and managers can create stock movements"
  on public.stock_movements for insert
  with check (public.is_user_admin_or_manager());

-- Allow authenticated users to create stock movements (for trigger functions)
-- This is needed for sale transactions to create stock movements
create policy "Authenticated users can create stock movements via triggers"
  on public.stock_movements for insert
  with check (auth.role() = 'authenticated');

-- RLS Policies for purchase_orders
create policy "Authenticated users can view purchase orders"
  on public.purchase_orders for select
  using (auth.role() = 'authenticated');

create policy "Admins and managers can manage purchase orders"
  on public.purchase_orders for all
  using (public.is_user_admin_or_manager());

-- RLS Policies for purchase_order_items
create policy "Authenticated users can view purchase order items"
  on public.purchase_order_items for select
  using (auth.role() = 'authenticated');

create policy "Admins and managers can manage purchase order items"
  on public.purchase_order_items for all
  using (public.is_user_admin_or_manager());

-- RLS Policies for customer_payments
create policy "Authenticated users can view customer payments"
  on public.customer_payments for select
  using (auth.role() = 'authenticated');

create policy "Authenticated users can create customer payments"
  on public.customer_payments for insert
  with check (auth.role() = 'authenticated');

-- =====================================================
-- SEED DATA
-- =====================================================

-- Insert default branch
insert into public.branches (name, address, phone, email) values
('Main Branch', '123 Main Street, Accra', '0244123456', 'main@deemart.com')
on conflict do nothing;

-- Insert categories
insert into public.categories (name, description) values
('Beverages', 'Soft drinks, juices, and other beverages'),
('Groceries', 'Food items and cooking ingredients'),
('Household', 'Household cleaning and maintenance items'),
('Personal Care', 'Personal hygiene and care products'),
('Snacks', 'Chips, biscuits, and other snacks')
on conflict (name) do nothing;

-- Insert sample suppliers
insert into public.suppliers (name, contact_person, phone, email, address) values
('Global Distributors Ltd', 'Mr. Asante', '0244000001', 'sales@globaldist.com', 'Accra Industrial Area'),
('Fresh Foods Ghana', 'Sarah Osei', '0200111222', 'orders@freshfoods.gh', 'Tema Community 1'),
('Tech Supplies Co', 'Kojo Antwi', '0555333444', 'info@techsupplies.com', 'Kumasi Adum')
on conflict do nothing;

-- Insert sample products (assuming categories were inserted with IDs 1-5)
insert into public.products (name, barcode, category_id, retail_price, cost_price, stock_quantity, min_stock_level, supplier_id) values
('Coca Cola 350ml', '5449000000996', 1, 5.00, 3.50, 100, 20, 1),
('Pepsi 350ml', '4060800107596', 1, 5.00, 3.50, 100, 20, 1),
('Gino Tomato Paste', '123456789', 2, 12.50, 8.00, 50, 10, 2),
('Key Soap Bar', '987654321', 3, 8.00, 5.00, 200, 30, 2),
('Milo 400g', '888888888', 2, 25.00, 18.00, 75, 15, 2),
('Indomie Noodles', '777777777', 2, 3.50, 2.00, 300, 50, 2)
on conflict (barcode) do nothing;

-- Insert sample customers
insert into public.customers (name, phone, email, credit_limit) values
('John Doe', '0244123456', 'john@example.com', 500.00),
('Jane Smith', '0200987654', 'jane@example.com', 1000.00),
('Kwame Mensah', '0555112233', 'kwame@example.com', 200.00)
on conflict do nothing;

-- =====================================================
-- GRANT PERMISSIONS
-- =====================================================

-- Grant access to authenticated users
grant usage on schema public to authenticated;
grant all on all tables in schema public to authenticated;
grant all on all sequences in schema public to authenticated;
grant execute on all functions in schema public to authenticated;

-- Grant access to views
grant select on all tables in schema public to authenticated;

-- =====================================================
-- END OF SCHEMA
-- =====================================================
