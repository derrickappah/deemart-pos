import { supabase } from '../lib/supabaseClient';

export const createSale = async (saleData) => {
    // saleData = { 
    //   cashier_id, total_amount, payment_method, 
    //   customer_id, is_credit, amount_paid, balance_due,
    //   discount_amount, tax_amount,
    //   items: [{ product_id, quantity, unit_price, total_price, discount_percent, discount_amount }] 
    // }

    try {
        // Calculate totals
        const subtotal = saleData.total_amount || 0;
        const discountAmount = saleData.discount_amount || 0;
        const taxAmount = saleData.tax_amount || 0;
        const finalAmount = subtotal - discountAmount + taxAmount;
        const amountPaid = saleData.amount_paid || (saleData.is_credit ? 0 : finalAmount);
        const balanceDue = saleData.balance_due || (saleData.is_credit ? finalAmount : 0);
        const changeAmount = saleData.payment_method === 'cash' && !saleData.is_credit 
            ? Math.max(0, (saleData.amount_tendered || amountPaid) - finalAmount)
            : 0;

        // Validate customer_id if provided
        let validatedCustomerId = null;
        if (saleData.customer_id) {
            const customerIdStr = String(saleData.customer_id).trim();
            // Check if it looks like a barcode (contains dashes, spaces, etc.)
            if (customerIdStr.includes('-') || customerIdStr.includes(' ') || !/^\d+$/.test(customerIdStr)) {
                console.error('Invalid customer_id detected:', {
                    value: saleData.customer_id,
                    stringValue: customerIdStr
                });
                throw new Error(`Invalid customer_id: "${saleData.customer_id}" appears to be a barcode, not a customer ID.`);
            }
            validatedCustomerId = parseInt(customerIdStr, 10);
            if (isNaN(validatedCustomerId) || validatedCustomerId <= 0) {
                throw new Error(`Invalid customer_id: "${saleData.customer_id}" is not a valid customer ID.`);
            }
        }

        // Validate branch_id if provided
        let validatedBranchId = null;
        if (saleData.branch_id) {
            const branchIdStr = String(saleData.branch_id).trim();
            // Check if it looks like a barcode (contains dashes, spaces, etc.)
            if (branchIdStr.includes('-') || branchIdStr.includes(' ') || !/^\d+$/.test(branchIdStr)) {
                console.error('Invalid branch_id detected:', {
                    value: saleData.branch_id,
                    stringValue: branchIdStr
                });
                throw new Error(`Invalid branch_id: "${saleData.branch_id}" appears to be invalid.`);
            }
            validatedBranchId = parseInt(branchIdStr, 10);
            if (isNaN(validatedBranchId) || validatedBranchId <= 0) {
                throw new Error(`Invalid branch_id: "${saleData.branch_id}" is not a valid branch ID.`);
            }
        }

        // Log the sale data being inserted
        console.log('Creating sale with data:', {
            cashier_id: saleData.cashier_id,
            customer_id: validatedCustomerId,
            branch_id: validatedBranchId,
            total_amount: subtotal,
            final_amount: finalAmount
        });

        // 1. Create Sale Record (sale_number will be auto-generated by trigger)
        const saleInsertData = {
            cashier_id: saleData.cashier_id,
            customer_id: validatedCustomerId,
            branch_id: validatedBranchId,
            total_amount: subtotal,
            discount_amount: discountAmount,
            tax_amount: taxAmount,
            final_amount: finalAmount,
            payment_method: saleData.payment_method,
            is_credit: saleData.is_credit || false,
            amount_paid: amountPaid,
            balance_due: balanceDue,
            change_amount: changeAmount,
            status: 'completed'
        };

        // Final validation - ensure no string values in integer fields
        console.log('Sale insert data before database:', JSON.stringify(saleInsertData, null, 2));
        
        // Log the exact data being sent
        console.log('About to insert sale with data:', JSON.stringify(saleInsertData, null, 2));
        console.log('Data types:', {
            cashier_id: typeof saleInsertData.cashier_id,
            customer_id: typeof saleInsertData.customer_id,
            branch_id: typeof saleInsertData.branch_id,
            total_amount: typeof saleInsertData.total_amount,
            final_amount: typeof saleInsertData.final_amount
        });

        // Try inserting with minimal select to avoid potential join issues
        let sale;
        let saleError;
        
        // First attempt: insert with basic select
        const insertResult = await supabase
            .from('sales')
            .insert(saleInsertData)
            .select('id, sale_number, created_at')
            .single();
        
        sale = insertResult.data;
        saleError = insertResult.error;

        // If that fails, try without select and fetch separately
        if (saleError) {
            console.warn('Insert with select failed, trying without select:', saleError);
            
            // Try insert without select
            const { data: insertData, error: insertOnlyError } = await supabase
                .from('sales')
                .insert(saleInsertData)
                .select('id')
                .single();
            
            if (insertOnlyError) {
                console.error('Sale insert error details:', {
                    message: insertOnlyError.message,
                    details: insertOnlyError.details,
                    hint: insertOnlyError.hint,
                    code: insertOnlyError.code,
                    fullError: insertOnlyError
                });
                throw insertOnlyError;
            }
            
            // Fetch the complete sale record
            const { data: fetchedSale, error: fetchError } = await supabase
                .from('sales')
                .select('*')
                .eq('id', insertData.id)
                .single();
            
            if (fetchError) {
                console.error('Error fetching sale after insert:', fetchError);
                // Use the basic data we have
                sale = insertData;
            } else {
                sale = fetchedSale;
            }
        }

        if (!sale) {
            throw new Error('Failed to create sale: No sale data returned');
        }

        // Log items before processing for debugging
        console.log('Creating sale with items:', JSON.stringify(saleData.items, null, 2));

        // 2. Create Sale Items with strict validation
        const itemsToInsert = saleData.items.map((item, index) => {
            // Ensure product_id is a valid integer
            let productId;
            
            // Log the item for debugging
            console.log(`Processing sale item ${index + 1}:`, {
                product_id: item.product_id,
                product_id_type: typeof item.product_id,
                product_id_value: item.product_id,
                full_item: item
            });
            
            // Convert to string first to check for invalid characters
            const idStr = String(item.product_id || '').trim();
            
            // Check for barcode-like patterns (contains dashes, spaces, letters, etc.)
            if (idStr.includes('-') || idStr.includes(' ') || !/^\d+$/.test(idStr)) {
                console.error('CRITICAL: Invalid product_id detected (barcode-like):', {
                    value: item.product_id,
                    stringValue: idStr,
                    type: typeof item.product_id,
                    item: item,
                    index: index
                });
                throw new Error(`Invalid product_id at item ${index + 1}: "${item.product_id}" appears to be a barcode (contains non-numeric characters like dashes), not a product ID. Please remove this item from cart and add it again.`);
            }
            
            // Parse as integer
            if (typeof item.product_id === 'string') {
                productId = parseInt(idStr, 10);
            } else if (typeof item.product_id === 'number') {
                productId = Math.floor(item.product_id);
            } else {
                console.error('Unexpected product_id type:', {
                    value: item.product_id,
                    type: typeof item.product_id,
                    item: item
                });
                throw new Error(`Invalid product_id at item ${index + 1}: "${item.product_id}" has unexpected type "${typeof item.product_id}". Expected a number or numeric string.`);
            }
            
            // Final validation
            if (isNaN(productId) || productId <= 0 || !Number.isInteger(productId)) {
                console.error('Invalid product_id after parsing:', {
                    original: item.product_id,
                    parsed: productId,
                    item: item
                });
                throw new Error(`Invalid product_id at item ${index + 1}: "${item.product_id}" could not be converted to a valid positive integer.`);
            }

            // Create the item object with validated integer
            const validatedItem = {
                sale_id: sale.id,
                product_id: productId, // Must be integer
                quantity: parseInt(item.quantity) || 1,
                unit_price: parseFloat(item.unit_price) || 0,
                discount_percent: parseFloat(item.discount_percent) || 0,
                discount_amount: parseFloat(item.discount_amount) || 0,
                total_price: parseFloat(item.total_price) || 0
            };
            
            // Final check before returning
            if (typeof validatedItem.product_id !== 'number' || !Number.isInteger(validatedItem.product_id)) {
                console.error('CRITICAL: product_id is not an integer after validation:', validatedItem);
                throw new Error(`Internal error: product_id validation failed for item ${index + 1}`);
            }
            
            console.log(`Item ${index + 1} validated successfully:`, {
                original_id: item.product_id,
                validated_product_id: validatedItem.product_id,
                product_id_type: typeof validatedItem.product_id
            });
            
            return validatedItem;
        });
        
        // Final validation of all items before database insert
        console.log('Final items to insert:', JSON.stringify(itemsToInsert, null, 2));
        
        // Deep validation - check string representation too
        const finalValidatedItems = itemsToInsert.map((item, index) => {
            // Check the actual value, not just the type
            const productIdStr = String(item.product_id);
            if (productIdStr.includes('-') || productIdStr.includes(' ') || !/^\d+$/.test(productIdStr)) {
                console.error('CRITICAL: Item has barcode-like product_id even after validation:', {
                    item: item,
                    product_id: item.product_id,
                    stringValue: productIdStr,
                    index: index
                });
                throw new Error(`CRITICAL ERROR: Item ${index + 1} has invalid product_id "${item.product_id}" (string: "${productIdStr}"). This should have been caught earlier.`);
            }
            
            if (typeof item.product_id !== 'number' || !Number.isInteger(item.product_id)) {
                console.error('CRITICAL: Item has non-integer product_id before database insert:', item);
                throw new Error(`Internal error: Item ${index + 1} has invalid product_id type before database insert: ${typeof item.product_id}`);
            }
            
            // Force conversion to ensure it's a number
            return {
                ...item,
                product_id: Number(item.product_id) // Force number conversion
            };
        });
        
        console.log('Final validated items (after force conversion):', JSON.stringify(finalValidatedItems, null, 2));
        
        // One more check - serialize and deserialize to ensure types are correct
        const serializedItems = JSON.parse(JSON.stringify(finalValidatedItems));
        serializedItems.forEach((item, index) => {
            // After JSON serialization, check again
            const idStr = String(item.product_id);
            if (idStr.includes('-') || idStr.includes(' ') || !/^\d+$/.test(idStr)) {
                console.error('CRITICAL: After JSON serialization, item still has invalid product_id:', item);
                throw new Error(`CRITICAL: Item ${index + 1} has invalid product_id after serialization: "${item.product_id}"`);
            }
            // Ensure it's a number
            item.product_id = parseInt(idStr, 10);
            if (isNaN(item.product_id) || item.product_id <= 0) {
                throw new Error(`CRITICAL: Item ${index + 1} product_id could not be converted to integer: "${item.product_id}"`);
            }
        });
        
        console.log('Items after final serialization check:', JSON.stringify(serializedItems, null, 2));

        // Create a completely new array with only the fields we need, ensuring types are correct
        const finalItemsForInsert = serializedItems.map((item, index) => {
            // Extract and validate product_id one more time
            let productId = item.product_id;
            
            // Convert to string to check format
            const idStr = String(productId);
            if (idStr.includes('-') || idStr.includes(' ') || !/^\d+$/.test(idStr)) {
                console.error('FINAL CHECK FAILED - Invalid product_id:', {
                    original: item.product_id,
                    stringValue: idStr,
                    item: item,
                    index: index
                });
                throw new Error(`FINAL VALIDATION FAILED: Item ${index + 1} has invalid product_id "${item.product_id}". This should never happen.`);
            }
            
            // Force to integer
            productId = parseInt(idStr, 10);
            if (isNaN(productId) || productId <= 0 || !Number.isInteger(productId)) {
                throw new Error(`FINAL VALIDATION FAILED: Item ${index + 1} product_id "${item.product_id}" is not a valid integer.`);
            }
            
            // Create new object with only the fields we need
            return {
                sale_id: sale.id,
                product_id: productId, // Explicitly set as integer
                quantity: parseInt(item.quantity) || 1,
                unit_price: parseFloat(item.unit_price) || 0,
                discount_percent: parseFloat(item.discount_percent) || 0,
                discount_amount: parseFloat(item.discount_amount) || 0,
                total_price: parseFloat(item.total_price) || 0
            };
        });
        
        // Final type check
        finalItemsForInsert.forEach((item, index) => {
            if (typeof item.product_id !== 'number') {
                console.error('ABSOLUTE FINAL CHECK - product_id is not a number:', item);
                throw new Error(`ABSOLUTE FINAL CHECK FAILED: Item ${index + 1} product_id is type "${typeof item.product_id}", expected "number"`);
            }
            if (!Number.isInteger(item.product_id)) {
                console.error('ABSOLUTE FINAL CHECK - product_id is not an integer:', item);
                throw new Error(`ABSOLUTE FINAL CHECK FAILED: Item ${index + 1} product_id is not an integer`);
            }
        });
        
        console.log('ABSOLUTE FINAL items for database insert:', JSON.stringify(finalItemsForInsert, null, 2));
        console.log('Type check of first item product_id:', typeof finalItemsForInsert[0]?.product_id, finalItemsForInsert[0]?.product_id);

        const { error: itemsError } = await supabase
            .from('sale_items')
            .insert(finalItemsForInsert);

        if (itemsError) throw itemsError;

        // 3. Create payment records for split payments
        if (saleData.split_payments && saleData.split_payments.length > 0) {
            const paymentRecords = saleData.split_payments.map(payment => ({
                sale_id: sale.id,
                payment_method: payment.method,
                amount: parseFloat(payment.amount) || 0
            }));

            const { error: paymentError } = await supabase
                .from('payment_records')
                .insert(paymentRecords);

            if (paymentError) {
                console.warn('Failed to create payment records:', paymentError);
                // Don't fail the sale if payment records fail
            }
        }

        return { success: true, sale, data: sale };

    } catch (error) {
        console.error('Sale creation failed:', error.message);
        return { success: false, error: error.message };
    }
};

export const getDailySalesSummary = async () => {
    try {
        const today = new Date().toISOString().split('T')[0];
        const { data, error } = await supabase
            .from('sales')
            .select('final_amount, id')
            .eq('status', 'completed')
            .gte('created_at', `${today}T00:00:00`)
            .lte('created_at', `${today}T23:59:59`);

        if (error) throw error;

        const totalSales = data.reduce((sum, sale) => sum + (parseFloat(sale.final_amount) || 0), 0);
        const totalOrders = data.length;

        return { totalSales, totalOrders };
    } catch (error) {
        console.error('Error fetching daily sales summary:', error.message);
        throw error; // Re-throw to let caller handle it
    }
};

export const getSales = async (startDate, endDate) => {
    try {
        let query = supabase
            .from('sales')
            .select(`
        *,
        sale_items (
          *,
          products (name)
        ),
        customers (name, phone)
      `)
            .order('created_at', { ascending: false });

        if (startDate) query = query.gte('created_at', `${startDate}T00:00:00`);
        if (endDate) query = query.lte('created_at', `${endDate}T23:59:59`);

        const { data, error } = await query;

        if (error) throw error;
        
        // Transform data to include total_amount for backward compatibility
        return (data || []).map(sale => ({
            ...sale,
            total_amount: sale.final_amount || sale.total_amount
        }));
    } catch (error) {
        console.error('Error fetching sales:', error.message);
        throw error; // Re-throw to let caller handle it
    }
};
